% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/onlineModel.R
\name{onlineModel}
\alias{onlineModel}
\title{onlineModel}
\usage{
onlineModel(y, x, D, L, forget_factor, lambda_init, tau2_init, spconfig,
  sparse_lambda_tolerance, shrinkStepSize, delta_multiplier, ...)
}
\arguments{
\item{y}{vector}

\item{x}{the reuslt from getPreprocess \code{x}}

\item{D}{columns of original X}

\item{L}{maximize lag number}

\item{forget_factor}{Comprises ideally decreasing weights in range [0,1] indicating the importance of past values (generally, less significance for older values)}

\item{lambda_init}{the initial value for lambda, LASSO penalty}

\item{tau2_init}{the initial value of EM decomposition parameter, refer to the paper}

\item{spconfig}{spline configuration}

\item{sparse_lambda_tolerance}{favor smaller lambda within spaTol_c tolerance}

\item{shrinkStepSize}{adjust lambda before they get too crazy}

\item{delta_multiplier}{multipler to move among channels}

\item{...}{default parameters,including
 \itemize{
  \item testSize: the number of obs to average prediction error, default is 50
  \item tol_idle_tau2:increase tau2 if it idles for a while
  \item safeShrink_lambda : adjust lambda before they get too crazy
  \item tol_all0times: if coefficents are all 0 for too long time, shrink lambda
  \item shrinktau2: how to shrink tau2
}}
}
\value{
a list including
 \itemize{
  \item preErr: historical predicted error, firt column indicates the first channel, etc.
  \item predict1 : historical predicted values, firt column indicates the first channel, etc.
  \item lambda_history : historical lambda channels, first channel is the smallest one and the third channel is the largest one.
  \item lambda_opt: optimized lambda, the second channel in lambda_history
  \item tau2_opt: optimized tau2
  \item beta_opt: best coefficient, the last row and the second channel related in beta_history
  \item beta_history: all stored coefficient.
}
}
\description{
This model is used to fit sequential non linear time series data. Detailed information could be find in the paper \url{http://jding.org/jie-uploads/2018/11/slant.pdf}
}
\details{
This function is for online streaming data
}
\examples{
\dontrun{
utils.lag <- function(ts, lag = 1, pad = NA) {
# return the lagged version of a time series vector
return(c(rep(pad, lag), ts[1:(length(ts)-lag)]))
}
# pack configurations so that it is easier to bundle things together

# Suppose that there is no historical data.
# In this situation, onlineModel has the same function as getSequentialNonlinearModel
Ex1 <- (function(N=2000, D=2, L=8, ifPlot = TRUE){
 err <- matrix(stats::rnorm(D*(N+L)), N+L, D)
 X <- err[ ,1]
 X <- cbind(X, 0.5 * utils.lag(X,1)^2 - 0.8 * utils.lag(X,7) + 0.2 * err[,2])
 if (ifPlot) {
   graphics::plot(X[,1], X[,2], pch = 16, cex = 0.5, col = "red")
 }
 list(N=N, D=D, L=L, X=X[-(1:L),], y=X[-(1:L),2])
})()

Ex1_algo <- (function(experiment_config){
ec <- experiment_config # short name
forget_factor <- 1/c(1:ec$N) # same as batch
shrinkStepSize <- 1/c(1:ec$N)
list(
  order = 3,
  nBspline = 10,
  forget_factor = forget_factor,
  shrinkStepSize = shrinkStepSize,
  # if the performance does not exceed this ratio, the sparser (larger lambda) is preferred
  sparse_lambda_tolerance = 1.01,
  delta_multiplier = 10^(0.4), # multipler to move among channels
 safeShrink_lambda = 10^(0.1), # to adjust lambda before they get too crazy
  lambda_init = 0.01,
  tau2_init = 0.05
)
})(Ex1)

Ex1_algo <- c(Ex1_algo, do.call(getPreprocess, c(Ex1,Ex1_algo)))
par <- c(list(ifPrint=1,testSize=50),Ex1,Ex1_algo)
Ex1_result <- do.call(onlineModel, par)

#Suppose that there is historical data
newEx1 <- (function(N=20, D=2, L=8, ifPlot = TRUE){
err <- matrix(rnorm(D*(N+L)), N+L, D)
X <- err[ ,1]
X <- cbind(X, 0.5 * utils.lag(X,1)^2 - 0.8 * utils.lag(X,7) + 0.2 * err[,2])
list(N=N, D=D, L=L, X=X[-(1:L),], y=X[-(1:L),2])
})()
Ex1_new <- (function(experiment_config){
 forget_factor <- 1/c(1:experiment_config$N) # same as batch
 shrinkStepSize <- 1/c(1:experiment_config$N)
 list(
   order = 3,
   nBspline = 10,
   forget_factor = forget_factor,
   shrinkStepSize = shrinkStepSize,
   # if the performance does not exceed this ratio, the sparser (larger lambda) is preferred
   sparse_lambda_tolerance = 1.1,
   delta_multiplier = 10^(0.4), # multipler to move among channels
   safeShrink_lambda = 10^(0.1), # to adjust lambda before they get too crazy
   lambda_init = 0.05, #lambda in the paper,three channel
   tau2_init = 0.05 #tao in the paper
   )
})(newEx1)
Ex1_new <- c(Ex1_new, do.call(getPreprocess, c(newEx1, Ex1_new)))
par <- c(list(ifPrint=1,testSize=50),newEx1,Ex1_new)
#newsult <- do.call(onlineModel,par)
}
}
\seealso{
\code{\link{glasso_EM}} for implementation of EM algorithm; \code{\link{getPreprocess}};\code{\link{getRegressor}}
}
\keyword{linear}
\keyword{model}
\keyword{non}
\keyword{sequential}
\keyword{series}
\keyword{time}
