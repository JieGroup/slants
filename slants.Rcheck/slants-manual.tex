\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `slants'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Title]\AsIs{Sequential Adaptive Nonlinear Modeling of Time Series}
\item[Version]\AsIs{0.0.1}
\item[Description]\AsIs{SLANTS is a new method for online modeling and prediction of nonlinear autoregressive time sereis. It uses splines to approximate a wide range of nonlinear functions. It can be applied to high dimensional time series where the dimension is larger than the sample size.}
\item[Depends]\AsIs{R (>= 3.5.0)}
\item[License]\AsIs{GPL-3}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{true}
\item[Imports]\AsIs{matrixStats (>= 0.54.0), MASS (>= 7.3.5), ncvreg (>= 3.11.0),
stats (>= 3.5.1), graphics (>= 3.5.1)}
\item[RoxygenNote]\AsIs{6.1.1.9000}
\item[Suggests]\AsIs{knitr, rmarkdown}
\item[VignetteBuilder]\AsIs{knitr}
\item[NeedsCompilation]\AsIs{no}
\item[Author]\AsIs{Jiaqi Liu [aut, trl],
Rachit Jas [aut, trl],
Qiuyi Han [aut],
Jie Ding [aut, cre]}
\item[Maintainer]\AsIs{Jie Ding }\email{dingj@umn.edu}\AsIs{}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{augknt}{augknt}{augknt}
%
\begin{Description}\relax
This function is to find the knot
\end{Description}
%
\begin{Usage}
\begin{verbatim}
augknt(boundary, nBspline, order)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{boundary}] boundary of knots

\item[\code{nBspline}] number of b splines

\item[\code{order}] order of polynomial
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
getRegressor()
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getPreprocess}{get Preprocess}{getPreprocess}
%
\begin{Description}\relax
This function preprocess the original data to get splines configuration and input data for b splines.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getPreprocess(X, L, order, nBspline, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{X}] The origianl input data.

\item[\code{L}] The maximum lag.

\item[\code{order}] order of b splines.

\item[\code{nBspline}] number of B splines.

\item[\code{...}] defualt parameters,including
\begin{itemize}

\item scaleFlag: boolean type,if true, standardize the columns of X, default to TRUE
\item augkntFlag:if false, use linear regressor, defaul to TRUE

\end{itemize}

\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list including
\begin{itemize}

\item x: reformed data
\item scale : standard deviation for original input
\item feasibleBox : the region of X where the spline fit is very accurate
\item knotBox: determine the knot range IN RESCALED SCALE, which is slightly larger than feasibleBox in quantile
\item knots ：knots
\item spconfig: splines configuration for b splines

\end{itemize}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
getPreprocess()
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getRegressor}{get Regressor}{getRegressor}
%
\begin{Description}\relax
This function preprocess the original data to get splines configuration and input data for b splines.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getRegressor(x, d, spconfig)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] input data, vector x

\item[\code{d}] the index of which knots to look at

\item[\code{spconfig}] splines configuration

\item[\code{order}] order of b splines.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a vector of regressor that will be passed to EM algorithm
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
x =  matrix(rnorm(2*(1000+8)),1000+8, 2)
knotBox = apply(x, 2, quantile, c(0.02,0.98), na.rm = TRUE)
knots = apply(knotBox, 2, augknt, nBspline, order)
spconfig = list(order = 3, nBspline = 10, knots = knots,knotBox = knotBox)
regressor <- getRegressor(x[,1],1,spconfig)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getSequentialNonlinearModel}{getSequentialNonlinearModel}{getSequentialNonlinearModel}
\keyword{linear}{getSequentialNonlinearModel}
\keyword{model}{getSequentialNonlinearModel}
\keyword{non}{getSequentialNonlinearModel}
\keyword{sequential}{getSequentialNonlinearModel}
\keyword{series}{getSequentialNonlinearModel}
\keyword{time}{getSequentialNonlinearModel}
%
\begin{Description}\relax
This model is used to fit sequential non linear time series data. Detailed information could be find in the paper \url{http://jding.org/jie-uploads/2018/11/slant.pdf}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getSequentialNonlinearModel(y, x, D, L, lambda, gamma_init, alpha2_init,
  spconfig, spaTol_gamma, shrinkStepSize, moveSize, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] vector

\item[\code{x}] the reuslt from getPreprocess \code{x}

\item[\code{D}] columns of original X

\item[\code{L}] maximize lag number

\item[\code{lambda}] the LASSO penalty

\item[\code{alpha2\_init}] the initial value of EM decomposition parameter, refer to the paper

\item[\code{spconfig}] spline configuration

\item[\code{spaTol\_gamma}] favor smaller gamma within spaTol\_c tolerance

\item[\code{shrinkStepSize}] adjust gamma before they get too crazy

\item[\code{moveSize}] multipler to move among channels

\item[\code{...}] default parameters,including
\begin{itemize}

\item testSize: the number of obs to average prediction error, default is 50
\item tol\_idle\_alpha2:increase alpha2 if it idles for a while
\item safeShrink\_gamma : adjust gamma before they get too crazy
\item tol\_all0times: if coefficents are all 0 for too long time, shrink gamma
\item shrinkAlpha2 ：how to shrink alpha2 if it's too big

\end{itemize}

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function is to fit seqential non linear model
\end{Details}
%
\begin{Value}
a list including
\begin{itemize}

\item preErr: historical predicted error, firt column indicates the first channel, etc.
\item predict1 : historical predicted values, firt column indicates the first channel, etc.
\item gamma\_history : historical gamma channels, first channel is the smallest one and the third channel is the largest one.
\item gamma\_opt: optimized gamma, the second channel in gamma\_history
\item alpha\_opt ：optimized alpha.
\item beta\_opt: best coefficient, the last row and the second channel related in beta\_history
\item beta\_history: all stored coefficient.

\end{itemize}

\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{glasso\_EM}{glasso.Rul.EM}} for implementation of EM algorithm; \code{\LinkA{getPreprocess}{getPreprocess}};\code{\LinkA{getRegressor}{getRegressor}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
utils.lag <- function(ts, lag = 1, pad = NA) {
# return the lagged version of a time series vector
return(c(rep(pad, lag), ts[1:(length(ts)-lag)]))
}
# pack configurations so that it is easier to bundle things together
Ex1 <- (function(N=2000, D=2, L=8, ifPlot = TRUE){
 err <- matrix(rnorm(D*(N+L)), N+L, D)
 X <- err[ ,1]
 X <- cbind(X, 0.5 * utils.lag(X,1)^2 - 0.8 * utils.lag(X,7) + 0.2 * err[,2])
 if (ifPlot) {
   plot(X[,1], X[,2], pch = 16, cex = 0.5, col = "red")
 }
 list(N=N, D=D, L=L, X=X[-(1:L),], y=X[-(1:L),2])
})()

Ex1_algo <- (function(experiment_config){
ec <- experiment_config # short name
lambda <- 1/c(1:ec$N) # same as batch
shrinkStepSize <- 1/c(1:ec$N)
list(
  order = 3,
  nBspline = 10,
  lambda = lambda,
  shrinkStepSize = shrinkStepSize,
  # if the performance does not exceed this ratio, the sparser (larger gamma) is preferred
  spaTol_gamma = 1.01,
  moveSize = 10^(0.4), # multipler to move among channels
 safeShrink_gamma = 10^(0.1), # to adjust gamma before they get too crazy
  gamma_init = 0.01,
  alpha2_init = 0.05
)
})(Ex1)

Ex1_algo <- c(Ex1_algo, do.call(getPreprocess, c(Ex1, Ex1_algo)))

Ex1_result <- do.call(getSequentialNonlinearModel, c(list(ifPrint=TRUE, testSize=50),Ex1, Ex1_algo))
========diagonistic========
plot(Ex1_result$gamma_opt,type = "l")
plot(Ex1_result$alpha_opt,type = "l",ylab = "Tao2")
plot(Ex1_result$preErr[,2],type = "l")
#get the historical opt beta, always the middle channel
beta_hist_opt <- Ex1_result$beta_history[,161:320]

order <- 3
knots <- Ex1_algo$knots[,1]
for (t in length(beta_hist)){
tmp <- NULL
for (i in 1:(length(knots)-order)) {
 tmp <- cbind(tmp, sapply(seq(-1,1,by=0.01), spval, x=knots[i:(i+order)]))
}
par(mfrow = c(1,2))
plot(seq(-1,1,by=0.01), tmp %*% beta_hist_opt[t,1:10])
plot(seq(-1,1,by=0.01), tmp %*% beta_hist_opt[t,121:130])
par(mfrow=c(1,1))
}

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{glasso\_EM}{glasso\_EM}{glasso.Rul.EM}
%
\begin{Description}\relax
This function is to implement the em algorithm for group lasso
\end{Description}
%
\begin{Usage}
\begin{verbatim}
glasso_EM(beta_init, A, B, ngroup, lambda, alpha2, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta\_init}] initial value

\item[\code{A}] sufficient statistics, matrix

\item[\code{B}] sufficient statistics

\item[\code{ngroup}] number of groups

\item[\code{lambda}] the LASSO penalty

\item[\code{alpha2}] the EM decomposition parameter, refer to the paper

\item[\code{...}] default parameters
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list of whether success and the updated coefficients
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
getRegressor()
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotcoeff}{plotcoeff}{plotcoeff}
%
\begin{Description}\relax
This function is to plot the coefficient
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotcoeff(beta, knots, nBspline)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta}] optimal coefficients

\item[\code{knots}] knots that returned from getPreprocess function

\item[\code{nBspline}] the numbers of B splines that we need to fit model, also returned from getPreprocess function
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
positive.polynomial(0.2,x = 0,k = 3,end_knot = 2,d=0)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{positive.polynomial}{positive.polynomial}{positive.polynomial}
%
\begin{Description}\relax
This function is to fit model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
positive.polynomial(t, x, k, end_knot, d = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{t}] the input value

\item[\code{x}] knots value

\item[\code{k}] order

\item[\code{end\_knot}] the largest value for knot

\item[\code{d}] the dth derivative if wanted
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a number of positive polynomial result
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
positive.polynomial(0.2,x = 0,k = 3,end_knot = 2,d=0)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{spval}{divided difference}{spval}
%
\begin{Description}\relax
This function is to calculate single value of regressor
\end{Description}
%
\begin{Usage}
\begin{verbatim}
spval(t, x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{t}] input x value

\item[\code{x}] knots
\end{ldescription}
\end{Arguments}
%
\begin{Value}
regressor value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
getRegressor()
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
